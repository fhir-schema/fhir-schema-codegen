import path from 'path';

import { Generator, GeneratorOptions } from '../../generator';
import { ClassField, TypeSchema } from '../../typeschema';
import { groupedByPackage, kebabCase, pascalCase, removeConstraints } from '../../utils';

// Naming conventions
// directory naming: kebab-case
// file naming: PascalCase for only-class files, kebab-case for other files
// function naming: camelCase
// class naming: PascalCase

export interface TypeScriptGeneratorOptions extends GeneratorOptions {
    // tabSize: 2
}

const typeMap = {
    boolean: 'boolean',
    instant: 'string',
    time: 'string',
    date: 'string',
    dateTime: 'string',

    decimal: 'number',
    integer: 'number',
    unsignedInt: 'number',
    positiveInt: 'number',
    integer64: 'number',
    base64Binary: 'string',

    uri: 'string',
    url: 'string',
    canonical: 'string',
    oid: 'string',
    uuid: 'string',

    string: 'string',
    code: 'string',
    markdown: 'string',
    id: 'string',
    xhtml: 'string',
};

// prettier-ignore
const keywords = new Set([
    'abstract', 'any', 'as', 'async', 'await', 'boolean', 'bigint', 'break', 
    'case', 'catch', 'class', 'const', 'constructor', 'continue', 'debugger', 
    'declare', 'default', 'delete', 'do', 'else', 'enum', 'export', 'extends', 
    'extern', 'false', 'finally', 'for', 'function', 'from', 'get', 'goto', 'if', 
    'implements', 'import', 'in', 'infer', 'instanceof', 'interface', 'keyof', 
    'let', 'module', 'namespace', 'never', 'new', 'null', 'number', 'object', 
    'of', 'override', 'private', 'protected', 'public', 'readonly', 'return', 
    'satisfies', 'set', 'static', 'string', 'super', 'switch', 'this', 'throw', 
    'true', 'try', 'type', 'typeof', 'unknown', 'var', 'void', 'while',
]);


export class TypeScriptGenerator extends Generator {
    constructor(opts: TypeScriptGeneratorOptions) {
        super({
            ...opts,
            typeMap,
            keywords,
            staticDir: path.resolve(__dirname, 'static'),
        });
    }

    generateDependenciesImports(schema: TypeSchema) {
        if (schema.allDependencies) {
            const deps = schema.allDependencies
                .filter((dep) => dep.type === 'complex-type' || dep.type === 'resource')
                .sort((a, b) => a.name.localeCompare(b.name));

            for (const dep of deps) {
                this.lineSM(`import { ${dep.name} } from './${dep.name}'`);
            }
        }
    }

    generateDisclaimer() {
        this.line('// WARNING: This file is autogenerated by FHIR Schema Codegen.');
        this.line('// https://github.com/fhir-schema/fhir-schema-codegen');
        this.line('// Any manual changes made to this file may be overwritten.');
    }

    generateNestedTypes(schema: TypeSchema) {
        if (schema.nestedTypes) {
            this.line('// Nested Types');
            this.line();
            for (let subtype of schema.nestedTypes) {
                this.generateType(subtype);
            }
        }
    }

    addFieldExtension(fieldName: string, field: ClassField): void {
        if (field.type.type === 'primitive-type') {
            this.lineSM(`_${fieldName}?: Element`);
        }
    }

    addResourceTypeField(schema: TypeSchema): void {
        this.lineSM(`resourceType: '${schema.name.name}'`);
    }

    generateType(schema: TypeSchema) {
        let base = schema.base ? `= ${schema.base.name} &` : '';

        this.curlyBlock(['export', 'type', schema.name.name, base], () => {
            if (!schema.fields) {
                return;
            }

            // we have to provide utility field name called resourceType
            if (schema.kind === 'resource') {
                this.addResourceTypeField(schema);
            }

            const fields = Object.entries(schema.fields).sort((a, b) => a[0].localeCompare(b[0]));

            for (const [fieldName, field] of fields) {
                const type = this.getFieldType(field);
                const fieldNameFixed = this.getFieldName(fieldName);
                const optionalSymbol = field.required ? '' : '?';
                const arraySymbol = field.array ? '[]' : '';

                this.lineSM(`${fieldNameFixed}${optionalSymbol}:`, `${type}${arraySymbol}`);

                if (schema.kind === 'resource' || schema.kind === 'complex-type') {
                    this.addFieldExtension(fieldName, field);
                }
            }
        });

        this.line();
    }

    generateResourceModule(schema: TypeSchema) {
        this.file(pascalCase(schema.name.name) + '.ts', () => {
            this.generateDisclaimer();
            this.line();

            this.generateDependenciesImports(schema);
            this.line();

            this.generateNestedTypes(schema);

            this.line('// Resource Type');
            this.generateType(schema);
        });
    }

    generate() {
        this.copyStaticFiles();

        this.dir('types', async () => {
            const typesToGenerate = [...this.loader.complexTypes(), ...this.loader.resources()];
            const groupedComplexTypes = groupedByPackage(typesToGenerate);

            for (const [packageName, packageResources] of Object.entries(groupedComplexTypes)) {
                this.dir(path.join('types', kebabCase(packageName)), () => {
                    for (let schema of removeConstraints(packageResources)) {
                        this.generateResourceModule(schema);
                    }
                });
            }
        });
    }
}

export const createGenerator = (options: TypeScriptGeneratorOptions) => new TypeScriptGenerator(options);
