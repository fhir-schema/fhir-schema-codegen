import path from 'path';

import { Generator, GeneratorOptions } from '@fscg/generator';
import { TypeSchema } from '@fscg/typeschema';
import { groupedByPackage, kebabCase, pascalCase, removeConstraints } from '@fscg/utils';

// Naming conventions
// directory naming: kebab-case
// file naming: PascalCase for only-class files, kebab-case for other files
// function naming: camelCase
// class naming: PascalCase

export interface TypeScriptGeneratorOptions extends GeneratorOptions {
    generateClasses?: boolean;
}

const typeMap: Record<string, string> = {
    boolean: 'boolean',
    instant: 'string',
    time: 'string',
    date: 'string',
    dateTime: 'string',

    decimal: 'number',
    integer: 'number',
    unsignedInt: 'number',
    positiveInt: 'number',
    integer64: 'number',
    base64Binary: 'string',

    uri: 'string',
    url: 'string',
    canonical: 'string',
    oid: 'string',
    uuid: 'string',

    string: 'string',
    code: 'string',
    markdown: 'string',
    id: 'string',
    xhtml: 'string',
};

const keywords = new Set([
    'abstract',
    'any',
    'as',
    'async',
    'await',
    'boolean',
    'bigint',
    'break',
    'case',
    'catch',
    'class',
    'const',
    'constructor',
    'continue',
    'debugger',
    'declare',
    'default',
    'delete',
    'do',
    'else',
    'enum',
    'export',
    'extends',
    'extern',
    'false',
    'finally',
    'for',
    'function',
    'from',
    'get',
    'goto',
    'if',
    'implements',
    'import',
    'in',
    'infer',
    'instanceof',
    'interface',
    'keyof',
    'let',
    'module',
    'namespace',
    'never',
    'new',
    'null',
    'number',
    'object',
    'of',
    'override',
    'private',
    'protected',
    'public',
    'readonly',
    'return',
    'satisfies',
    'set',
    'static',
    'string',
    'super',
    'switch',
    'this',
    'throw',
    'true',
    'try',
    'type',
    'typeof',
    'unknown',
    'var',
    'void',
    'while',
]);

export class TypeScriptGenerator extends Generator {
    constructor(opts: TypeScriptGeneratorOptions) {
        super(opts);
        this.staticDir = path.resolve(__dirname, 'static');
    }

    generateDependenciesImports(schema: TypeSchema) {
        if (schema.allDependencies) {
            const complexTypesDeps = schema.allDependencies.filter((deps) => deps.type === 'complex-type');
            const resourceDeps = schema.allDependencies.filter((deps) => deps.type === 'resource');

            for (const dep of complexTypesDeps) {
                this.lineSM(`import { ${dep.name} } from './${dep.name}'`);
            }

            this.line()

            for (const dep of resourceDeps) {
                this.lineSM(`import { ${dep.name} } from './${dep.name}'`);
            }
        }
    }

    generateDisclaimer() {
        this.line('// WARNING: This file is autogenerated by FHIR Schema Codegen.');
        this.line('// https://github.com/fhir-schema/fhir-schema-codegen');
        this.line('// Any manual changes made to this file may be overwritten.');
    }

    generateNestedTypes(schema: TypeSchema) {
        if (schema.nestedTypes) {
            this.line('// Nested Types');
            this.line();
            for (let subtype of schema.nestedTypes) {
                this.generateType(subtype);
            }
        }
    }

    generateType(schema: TypeSchema) {
        let base = schema.base ? 'extends ' + schema.base.name : '';
        this.curlyBlock(['export', 'interface', schema.name.name, base], () => {
            if (schema.fields) {
                for (const [fieldName, field] of Object.entries(schema.fields).sort((a, b) =>
                    a[0].localeCompare(b[0])
                )) {
                    let tp = field.type.name;
                    let type = tp;
                    let fieldSymbol = fieldName;
                    if (!field.required) {
                        fieldSymbol += '?';
                    }
                    if (field.type.type == 'primitive-type') {
                        type = typeMap[tp] || 'string';
                    } else {
                        type = field.type.name;
                    }
                    this.lineSM(fieldSymbol, ':', type + (field.array ? '[]' : ''));
                }
            }
        });
        this.line();
    }

    generateResourceModule(schema: TypeSchema) {
        this.file(pascalCase(schema.name.name) + '.ts', () => {
            this.generateDisclaimer();
            this.line();

            this.generateDependenciesImports(schema);
            this.line();

            this.generateNestedTypes(schema);

            this.line('// Resource Type');
            this.line();
            this.generateType(schema);
        });
    }

    generate() {
        this.copyStaticFiles();

        this.dir('types', async () => {
            const groupedComplexTypes = groupedByPackage(this.loader.complexTypes());
            for (const [packageName, packageResources] of Object.entries(groupedComplexTypes)) {
                this.dir(path.join('types', kebabCase(packageName)), () => {
                    for (let schema of removeConstraints(packageResources)) {
                        this.generateResourceModule(schema);
                    }
                });
            }

            const groupedResources = groupedByPackage(this.loader.resources());
            for (const [packageName, packageResources] of Object.entries(groupedResources)) {
                this.dir(path.join('types', kebabCase(packageName)), () => {
                    for (let schema of removeConstraints(packageResources)) {
                        this.generateResourceModule(schema);
                    }
                });
            }
        });
    }
}

export const createGenerator = (options: TypeScriptGeneratorOptions) => new TypeScriptGenerator(options);
